---
description: NestJS Framework Development Rules
globs: ["**/*.ts", "**/*.js"]
alwaysApply: true
---

# NestJS Framework Development Rules

## Project Structure

### Core Directories
- `src/` - Main application source code
- `src/modules/` - Feature modules
- `src/common/` - Shared utilities, guards, interceptors
- `src/config/` - Configuration files
- `src/database/` - Database related files (entities, migrations)

### Module Structure
Each feature module should follow this structure:
```
src/modules/[feature-name]/
├── [feature-name].controller.ts
├── [feature-name].service.ts
├── [feature-name].module.ts
├── dto/
│   ├── create-[feature-name].dto.ts
│   └── update-[feature-name].dto.ts
├── entities/
│   └── [feature-name].entity.ts
└── interfaces/
    └── [feature-name].interface.ts
```

## Coding Standards

### File Naming Conventions
- **Controllers**: `[name].controller.ts`
- **Services**: `[name].service.ts`
- **Modules**: `[name].module.ts`
- **DTOs**: `[action]-[name].dto.ts` (e.g., `create-user.dto.ts`)
- **Entities**: `[name].entity.ts`
- **Interfaces**: `[name].interface.ts`
- **Guards**: `[name].guard.ts`
- **Interceptors**: `[name].interceptor.ts`
- **Pipes**: `[name].pipe.ts`

### Class Naming Conventions
- **Controllers**: `[Name]Controller` (e.g., `UserController`)
- **Services**: `[Name]Service` (e.g., `UserService`)
- **Modules**: `[Name]Module` (e.g., `UserModule`)
- **DTOs**: `[Action][Name]Dto` (e.g., `CreateUserDto`)
- **Entities**: `[Name]` (e.g., `User`)
- **Interfaces**: `I[Name]` (e.g., `IUser`)

## Dependency Injection

### Service Registration
```typescript
@Injectable()
export class UserService {
  // Service implementation
}
```

### Module Configuration
```typescript
@Module({
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
})
export class UserModule {}
```

## API Design Patterns

### Controller Structure
```typescript
@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Get()
  async findAll(): Promise<User[]> {
    return this.userService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<User> {
    return this.userService.findOne(id);
  }

  @Post()
  async create(@Body() createUserDto: CreateUserDto): Promise<User> {
    return this.userService.create(createUserDto);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateUserDto: UpdateUserDto,
  ): Promise<User> {
    return this.userService.update(id, updateUserDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<void> {
    return this.userService.remove(id);
  }
}
```

### Service Structure
```typescript
@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>,
  ) {}

  async findAll(): Promise<User[]> {
    return this.userRepository.find();
  }

  async findOne(id: string): Promise<User> {
    const user = await this.userRepository.findOne({ where: { id } });
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  async create(createUserDto: CreateUserDto): Promise<User> {
    const user = this.userRepository.create(createUserDto);
    return this.userRepository.save(user);
  }

  async update(id: string, updateUserDto: UpdateUserDto): Promise<User> {
    await this.findOne(id); // Check if user exists
    await this.userRepository.update(id, updateUserDto);
    return this.findOne(id);
  }

  async remove(id: string): Promise<void> {
    await this.findOne(id); // Check if user exists
    await this.userRepository.delete(id);
  }
}
```

## DTO (Data Transfer Object) Rules

### Validation DTOs
```typescript
import { IsString, IsEmail, IsOptional, MinLength } from 'class-validator';

export class CreateUserDto {
  @IsString()
  @MinLength(2)
  name: string;

  @IsEmail()
  email: string;

  @IsString()
  @MinLength(8)
  password: string;
}

export class UpdateUserDto {
  @IsOptional()
  @IsString()
  @MinLength(2)
  name?: string;

  @IsOptional()
  @IsEmail()
  email?: string;
}
```

## Error Handling

### Custom Exceptions
```typescript
export class UserNotFoundException extends NotFoundException {
  constructor(id: string) {
    super(`User with ID ${id} not found`);
  }
}
```

### Global Exception Filter
```typescript
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    const status = exception instanceof HttpException
      ? exception.getStatus()
      : HttpStatus.INTERNAL_SERVER_ERROR;

    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      message: exception instanceof HttpException
        ? exception.getResponse()
        : 'Internal server error',
    });
  }
}
```

## Database Integration

### Entity Definition
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  name: string;

  @Column({ unique: true })
  email: string;

  @Column()
  password: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

## Best Practices

1. **Single Responsibility**: Each service should handle one specific domain
2. **Dependency Injection**: Always use constructor injection
3. **Error Handling**: Use appropriate HTTP exceptions
4. **Validation**: Always validate input data with DTOs
5. **Type Safety**: Use TypeScript interfaces and types
6. **Testing**: Write unit tests for services and integration tests for controllers
7. **Documentation**: Use Swagger decorators for API documentation
8. **Security**: Implement proper authentication and authorization
9. **Performance**: Use appropriate caching strategies
10. **Logging**: Implement structured logging

## Swagger Documentation

### API Documentation Setup
```typescript
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

const config = new DocumentBuilder()
  .setTitle('API Documentation')
  .setDescription('The API description')
  .setVersion('1.0')
  .addTag('users')
  .build();

const document = SwaggerModule.createDocument(app, config);
SwaggerModule.setup('api', app, document);
```

### Controller Documentation
```typescript
@ApiTags('users')
@Controller('users')
export class UserController {
  @ApiOperation({ summary: 'Get all users' })
  @ApiResponse({ status: 200, description: 'Return all users.' })
  @Get()
  async findAll(): Promise<User[]> {
    return this.userService.findAll();
  }
}
```